<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="不卜个人博客，是一个记录博主学习和成长的个人博客站点。" />



  <meta name="keywords" content="python,python库,入门教程," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="Python命令行简单示例&amp;gt;&amp;gt;&amp;gt; resp = requests.get(&apos;https://api.github.com/user&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))
&amp;gt;&amp;gt;&amp;gt; resp.status_code
200
&amp;gt;&amp;gt;&amp;gt; resp.headers[&apos;content-type&apos;]
&apos;application/json; chars">
<meta property="og:type" content="article">
<meta property="og:title" content="python的requests库">
<meta property="og:url" content="http://kuku940.github.io/2015/09/13/python的requests库/index.html">
<meta property="og:site_name" content="不卜博客 - 不卜的个人博客站点">
<meta property="og:description" content="Python命令行简单示例&amp;gt;&amp;gt;&amp;gt; resp = requests.get(&apos;https://api.github.com/user&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))
&amp;gt;&amp;gt;&amp;gt; resp.status_code
200
&amp;gt;&amp;gt;&amp;gt; resp.headers[&apos;content-type&apos;]
&apos;application/json; chars">
<meta property="og:updated_time" content="2015-09-20T06:34:22.450Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python的requests库">
<meta name="twitter:description" content="Python命令行简单示例&amp;gt;&amp;gt;&amp;gt; resp = requests.get(&apos;https://api.github.com/user&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))
&amp;gt;&amp;gt;&amp;gt; resp.status_code
200
&amp;gt;&amp;gt;&amp;gt; resp.headers[&apos;content-type&apos;]
&apos;application/json; chars">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> python的requests库 | 不卜博客 - 不卜的个人博客站点 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a1718d105ac5c566eeca9ca427859200";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">不卜</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'szZeQCByKssqztmey91S','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              python的requests库
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-13T12:00:01+08:00" content="2015-09-13">
            2015-09-13
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/python/" itemprop="url" rel="index">
                  <span itemprop="name">python</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/13/python的requests库/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/13/python的requests库/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h1 id="Python命令行简单示例">Python命令行简单示例</h1><pre><code><span class="prompt">&gt;&gt;&gt; </span>resp = requests.get(<span class="string">'https://api.github.com/user'</span>, auth=(<span class="string">'user'</span>, <span class="string">'pass'</span>))
<span class="prompt">&gt;&gt;&gt; </span>resp.status_code
<span class="number">200</span>
<span class="prompt">&gt;&gt;&gt; </span>resp.headers[<span class="string">'content-type'</span>]
<span class="string">'application/json; charset=utf8'</span>
<span class="prompt">&gt;&gt;&gt; </span>resp.encoding
<span class="string">'utf-8'</span>
<span class="prompt">&gt;&gt;&gt; </span>resp.text
<span class="string">u'{"type":"User"...'</span>
<span class="prompt">&gt;&gt;&gt; </span>resp.json()
{<span class="string">u'private_gists'</span>: <span class="number">419</span>, <span class="string">u'total_private_repos'</span>: <span class="number">77</span>, ...}
</code></pre><a id="more"></a>
<h1 id="安装">安装</h1><p>使用<code>pip</code>或者<code>easy_install</code>安装<code>Requests</code></p>
<pre><code>pip <span class="keyword">install</span> requests
easy_install requests
</code></pre><h1 id="发送请求">发送请求</h1><p>使用Requests发送网络请求非常简单。</p>
<p>一开始要导入Requests模块:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import requests
</code></pre><p>然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://github.com/timeline.json'</span>)</span></span>
</code></pre><p>现在，我们有一个名为 r 的 Response 对象。可以从这个对象中获取所有我们想要的信息。</p>
<p>Requests简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求:</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">post</span><span class="params">(<span class="string">"http://httpbin.org/post"</span>)</span></span>
</code></pre><p>漂亮，对吧？那么其他HTTP请求类型：PUT， DELETE， HEAD以及OPTIONS又是如何的呢？都是一样的简单:</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">put</span><span class="params">(<span class="string">"http://httpbin.org/put"</span>)</span></span>
&gt;&gt;&gt; r = requests.<span class="function"><span class="title">delete</span><span class="params">(<span class="string">"http://httpbin.org/delete"</span>)</span></span>
&gt;&gt;&gt; r = requests.<span class="function"><span class="title">head</span><span class="params">(<span class="string">"http://httpbin.org/get"</span>)</span></span>
&gt;&gt;&gt; r = requests.<span class="function"><span class="title">options</span><span class="params">(<span class="string">"http://httpbin.org/get"</span>)</span></span>
</code></pre><p>都很不错吧，但这也仅是Requests的冰山一角呢。</p>
<h1 id="为URL传递参数">为URL传递参数</h1><p>你也许经常想为URL的查询字符串(query string)传递某种数据。如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如,    <code>httpbin.org/get?key=val</code> 。 Requests允许你使用 params 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; payload = {<span class="string">'key1'</span><span class="symbol">:</span> <span class="string">'value1'</span>, <span class="string">'key2'</span><span class="symbol">:</span> <span class="string">'value2'</span>}
<span class="prompt">&gt;&gt;</span>&gt; r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=payload)
</code></pre><p>通过打印输出该URL，你能看到URL已被正确编码:</p>
<pre><code>&gt;&gt;&gt; <span class="function"><span class="title">print</span><span class="params">(r.url)</span></span>
http:<span class="comment">//httpbin.org/get?key2=value2&amp;key1=value1</span>
</code></pre><p><strong>注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。</strong></p>
<h1 id="响应内容">响应内容</h1><p>我们能读取服务器响应的内容。再次以Github时间线为例:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import requests
<span class="prompt">&gt;&gt;</span>&gt; r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)
<span class="prompt">&gt;&gt;</span>&gt; r.text
u<span class="string">'[{"repository":{"open_issues":0,"url":"https://github.com/...</span>
</code></pre><p>Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。  </p>
<p>请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; r.encoding
<span class="string">'utf-8'</span>
<span class="prompt">&gt;&gt;</span>&gt; r.encoding = <span class="string">'ISO-8859-1'</span>
</code></pre><p>如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。</p>
<p>在你需要的情况下，Requests也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由Requests来为你处理编码。</p>
<h1 id="二进制响应内容">二进制响应内容</h1><p>你也能以字节的方式访问请求响应体，对于非文本请求:</p>
<pre><code>&gt;&gt;&gt; r.content
b'[{<span class="string">"repository"</span>:{<span class="string">"open_issues"</span>:<span class="number">0</span>,<span class="string">"url"</span>:<span class="string">"https://github.com/...</span>
</code></pre><p>Requests会自动为你解码 gzip 和 deflate 传输编码的响应数据。</p>
<p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码:</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO
<span class="prompt">&gt;&gt;&gt; </span>i = Image.open(StringIO(r.content))
</code></pre><h1 id="JSON响应内容">JSON响应内容</h1><p>Requests中也有一个内置的JSON解码器，助你处理JSON数据:</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> requests
<span class="prompt">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)
<span class="prompt">&gt;&gt;&gt; </span>r.json()
[{<span class="string">u'repository'</span>: {<span class="string">u'open_issues'</span>: <span class="number">0</span>, <span class="string">u'url'</span>: <span class="string">'https://github.com/...</span>
</code></pre><p>如果JSON解码失败， r.json 就会抛出一个异常。例如，相应内容是 401 (Unauthorized) ，尝试访问 r.json 将会抛出 ValueError: No JSON object could be decoded 异常。</p>
<h1 id="原始响应内容">原始响应内容</h1><p>在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw 。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True 。具体的你可以这么做:</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://github.com/timeline.json'</span>, stream=True)</span></span>
&gt;&gt;&gt; r<span class="class">.raw</span>
&lt;requests<span class="class">.packages</span><span class="class">.urllib3</span><span class="class">.response</span><span class="class">.HTTPResponse</span> <span class="tag">object</span> at <span class="number">0</span>x101194810&gt;
&gt;&gt;&gt; r<span class="class">.raw</span><span class="class">.read</span>(<span class="number">10</span>)
<span class="string">'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'</span>
</code></pre><p>但一般情况下，你应该下面的模式将文本流保存到文件:</p>
<pre><code>with <span class="function"><span class="title">open</span><span class="params">(filename, <span class="string">'wb'</span>)</span></span> as fd:
       <span class="keyword">for</span> chunk <span class="keyword">in</span> r.<span class="function"><span class="title">iter_content</span><span class="params">(chunk_size)</span></span>:
        fd.<span class="function"><span class="title">write</span><span class="params">(chunk)</span></span>
</code></pre><p>使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。</p>
<h1 id="定制请求头">定制请求头</h1><p>如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。</p>
<p>例如，在前一个示例中我们没有指定content-type:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import json
<span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'https://api.github.com/some/endpoint'</span>
<span class="prompt">&gt;&gt;</span>&gt; payload = {<span class="string">'some'</span><span class="symbol">:</span> <span class="string">'data'</span>}
<span class="prompt">&gt;&gt;</span>&gt; headers = {<span class="string">'content-type'</span><span class="symbol">:</span> <span class="string">'application/json'</span>}

<span class="prompt">&gt;&gt;</span>&gt; r = requests.post(url, data=json.dumps(payload), headers=headers)
</code></pre><h1 id="更加复杂的POST请求">更加复杂的POST请求</h1><p>通常，你想要发送一些编码为表单形式的数据—非常像一个HTML表单。 要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典 在发出请求时会自动编码为表单形式:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; payload = {<span class="string">'key1'</span><span class="symbol">:</span> <span class="string">'value1'</span>, <span class="string">'key2'</span><span class="symbol">:</span> <span class="string">'value2'</span>}
<span class="prompt">&gt;&gt;</span>&gt; r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)
<span class="prompt">&gt;&gt;</span>&gt; print r.text
{
  ...
  <span class="string">"form"</span><span class="symbol">:</span> {
    <span class="string">"key2"</span><span class="symbol">:</span> <span class="string">"value2"</span>,
    <span class="string">"key1"</span><span class="symbol">:</span> <span class="string">"value1"</span>
  },
  ...
}
</code></pre><p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict ，那么数据会被直接发布出去。</p>
<p>例如，Github API v3接受编码为JSON的POST/PATCH数据:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import json
<span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'https://api.github.com/some/endpoint'</span>
<span class="prompt">&gt;&gt;</span>&gt; payload = {<span class="string">'some'</span><span class="symbol">:</span> <span class="string">'data'</span>}

<span class="prompt">&gt;&gt;</span>&gt; r = requests.post(url, data=json.dumps(payload))
</code></pre><h1 id="POST一个多部分编码(Multipart-Encoded)的文件">POST一个多部分编码(Multipart-Encoded)的文件</h1><p>Requests使得上传多部分编码文件变得很简单:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'http://httpbin.org/post'</span>
<span class="prompt">&gt;&gt;</span>&gt; files = {<span class="string">'file'</span><span class="symbol">:</span> open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>)}

<span class="prompt">&gt;&gt;</span>&gt; r = requests.post(url, files=files)
<span class="prompt">&gt;&gt;</span>&gt; r.text
{
  ...
  <span class="string">"files"</span><span class="symbol">:</span> {
    <span class="string">"file"</span><span class="symbol">:</span> <span class="string">"&lt;censored...binary...data&gt;"</span>
  },
  ...
}
</code></pre><p>你可以显式地设置文件名，文件类型和请求头:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'http://httpbin.org/post'</span>
<span class="prompt">&gt;&gt;</span>&gt; files = {<span class="string">'file'</span><span class="symbol">:</span> (<span class="string">'report.xls'</span>, open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>), <span class="string">'application/vnd.ms-excel'</span>, {<span class="string">'Expires'</span><span class="symbol">:</span> <span class="string">'0'</span>})}

<span class="prompt">&gt;&gt;</span>&gt; r = requests.post(url, files=files)
<span class="prompt">&gt;&gt;</span>&gt; r.text
{
  ...
  <span class="string">"files"</span><span class="symbol">:</span> {
    <span class="string">"file"</span><span class="symbol">:</span> <span class="string">"&lt;censored...binary...data&gt;"</span>
  },
  ...
}
</code></pre><p>如果你想，你也可以发送作为文件来接收的字符串:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'http://httpbin.org/post'</span>
<span class="prompt">&gt;&gt;</span>&gt; files = {<span class="string">'file'</span><span class="symbol">:</span> (<span class="string">'report.csv'</span>, <span class="string">'some,data,to,send\nanother,row,to,send\n'</span>)}

<span class="prompt">&gt;&gt;</span>&gt; r = requests.post(url, files=files)
<span class="prompt">&gt;&gt;</span>&gt; r.text
{
  ...
  <span class="string">"files"</span><span class="symbol">:</span> {
    <span class="string">"file"</span><span class="symbol">:</span> <span class="string">"some,data,to,send\\nanother,row,to,send\\n"</span>
  },
  ...
}
</code></pre><p>如果你发送一个非常大的文件作为<code>multipart/form-data</code>请求，你可能希望流请求(?)。默认下 requests 不支持, 但有个第三方包支持 - requests-toolbelt. 你可以阅读 toolbelt 文档 来了解使用方法。</p>
<h1 id="响应状态码">响应状态码</h1><p>我们可以检测响应状态码:</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://httpbin.org/get'</span>)</span></span>
&gt;&gt;&gt; r<span class="class">.status_code</span>
<span class="number">200</span>
</code></pre><p>为方便引用，Requests还附带了一个内置的状态码查询对象:</p>
<pre><code>&gt;&gt;&gt; r<span class="class">.status_code</span> == requests<span class="class">.codes</span><span class="class">.ok</span>
True
</code></pre><p>如果发送了一个失败请求(非200响应)，我们可以通过 <code>Response.raise_for_status()</code>来抛出异常:</p>
<pre><code>&gt;&gt;&gt; bad_r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://httpbin.org/status/404'</span>)</span></span>
&gt;&gt;&gt; bad_r<span class="class">.status_code</span>
<span class="number">404</span>

&gt;&gt;&gt; bad_r.<span class="function"><span class="title">raise_for_status</span><span class="params">()</span></span>
Traceback (most recent call last):
  File <span class="string">"requests/models.py"</span>, line <span class="number">832</span>, <span class="keyword">in</span> raise_for_status
    raise http_error
requests<span class="class">.exceptions</span><span class="class">.HTTPError</span>: <span class="number">404</span> Client Error
</code></pre><p>但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是:</p>
<pre><code>&gt;&gt;&gt; r.<span class="function"><span class="title">raise_for_status</span><span class="params">()</span></span>
None
</code></pre><p>一切都挺和谐哈。</p>
<h1 id="响应头">响应头</h1><p>我们可以查看以一个Python字典形式展示的服务器响应头:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; r.headers
{
    <span class="string">'content-encoding'</span><span class="symbol">:</span> <span class="string">'gzip'</span>,
    <span class="string">'transfer-encoding'</span><span class="symbol">:</span> <span class="string">'chunked'</span>,
    <span class="string">'connection'</span><span class="symbol">:</span> <span class="string">'close'</span>,
    <span class="string">'server'</span><span class="symbol">:</span> <span class="string">'nginx/1.0.4'</span>,
    <span class="string">'x-runtime'</span><span class="symbol">:</span> <span class="string">'148ms'</span>,
    <span class="string">'etag'</span><span class="symbol">:</span> <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,
    <span class="string">'content-type'</span><span class="symbol">:</span> <span class="string">'application/json'</span>
}
</code></pre><p>但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。</p>
<p>因此，我们可以使用任意大写形式来访问这些响应头字段:</p>
<pre><code>&gt;&gt;&gt; r<span class="class">.headers</span>[<span class="string">'Content-Type'</span>]
<span class="string">'application/json'</span>

&gt;&gt;&gt; r<span class="class">.headers</span><span class="class">.get</span>(<span class="string">'content-type'</span>)
<span class="string">'application/json'</span>
Cookies
</code></pre><p>如果某个响应中包含一些Cookie，你可以快速访问它们:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'http://example.com/some/cookie/setting/url'</span>
<span class="prompt">&gt;&gt;</span>&gt; r = requests.get(url)

<span class="prompt">&gt;&gt;</span>&gt; r.cookies[<span class="string">'example_cookie_name'</span>]
<span class="string">'example_cookie_value'</span>
</code></pre><p>要想发送你的cookies到服务器，可以使用 cookies 参数:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'http://httpbin.org/cookies'</span>
<span class="prompt">&gt;&gt;</span>&gt; cookies = dict(cookies_are=<span class="string">'working'</span>)

<span class="prompt">&gt;&gt;</span>&gt; r = requests.get(url, cookies=cookies)
<span class="prompt">&gt;&gt;</span>&gt; r.text
<span class="string">'{"cookies": {"cookies_are": "working"}}'</span>
</code></pre><h1 id="重定向与请求历史">重定向与请求历史</h1><p>默认情况下，除了 HEAD, Requests会自动处理所有重定向。</p>
<p>可以使用响应对象的 history 方法来追踪重定向。</p>
<p>Response.history 是一个:class:Response <requests.response> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</requests.response></p>
<p>例如，Github将所有的HTTP请求重定向到HTTPS。:</p>
<pre><code>&gt;&gt;&gt; r = requests.get('http:<span class="comment">//github.com')</span>
&gt;&gt;&gt; r.url
'https:<span class="comment">//github.com/'</span>
&gt;&gt;&gt; r.status_code
<span class="number">200</span>
&gt;&gt;&gt; r.history
<span class="annotation">[&lt;Response [301]&gt;]</span>
</code></pre><p>如果你使用的是GET, OPTIONS, POST, PUT, PATCH 或者 DELETE,，那么你可以通过 allow_redirects 参数禁用重定向处理:</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://github.com'</span>, allow_redirects=False)</span></span>
&gt;&gt;&gt; r<span class="class">.status_code</span>
<span class="number">301</span>
&gt;&gt;&gt; r<span class="class">.history</span>
[]
</code></pre><p>如果你使用的是HEAD，你也可以启用重定向:</p>
<pre><code>&gt;&gt;&gt; r = requests.head('http:<span class="comment">//github.com', allow_redirects=True)</span>
&gt;&gt;&gt; r.url
'https:<span class="comment">//github.com/'</span>
&gt;&gt;&gt; r.history
<span class="annotation">[&lt;Response [301]&gt;]</span>
</code></pre><h1 id="超时">超时</h1><p>你可以告诉requests在经过以 timeout 参数设定的秒数时间之后停止等待响应:</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://github.com'</span>, timeout=<span class="number">0.001</span>)</span></span>
Traceback (most recent call last):
  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;
requests<span class="class">.exceptions</span><span class="class">.Timeout</span>: <span class="function"><span class="title">HTTPConnectionPool</span><span class="params">(host=<span class="string">'github.com'</span>, port=<span class="number">80</span>)</span></span>: Request timed out. (timeout=<span class="number">0.001</span>)
</code></pre><p><strong>注:</strong>  </p>
<blockquote>
<p>timeout 仅对连接过程有效，与响应体的下载无关。 timeout is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for timeout seconds (more precisely, if no bytes have been received on the underlying socket for timeout seconds).</p>
</blockquote>
<h1 id="错误与异常">错误与异常</h1><p>遇到网络问题（如：DNS查询失败、拒绝连接等）时，Requests会抛出一个 ConnectionError 异常。</p>
<p>遇到罕见的无效HTTP响应时，Requests则会抛出一个 HTTPError 异常。</p>
<p>若请求超时，则抛出一个 Timeout 异常。</p>
<p>若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。</p>
<p>所有Requests显式抛出的异常都继承自 <code>requests.exceptions.RequestException</code>。</p>
<p>#会话对象<br>会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。</p>
<p>会话对象具有主要的Requests API的所有方法。</p>
<p>我们来跨请求保持一些cookies:</p>
<pre><code>s = requests.Session()

s.<span class="literal">get</span>('http:<span class="comment">//httpbin.org/cookies/set/sessioncookie/123456789')</span>
r = s.<span class="literal">get</span>(<span class="string">"http://httpbin.org/cookies"</span>)

<span class="keyword">print</span>(r.text)
# '{<span class="string">"cookies"</span>: {<span class="string">"sessioncookie"</span>: <span class="string">"123456789"</span>}}'
</code></pre><p>会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的:</p>
<pre><code>s = requests.Session()
s.auth = (<span class="string">'user'</span>, <span class="string">'pass'</span>)
s.headers.update({<span class="string">'x-test'</span>: <span class="string">'true'</span>})

<span class="preprocessor"># both <span class="string">'x-test'</span> and <span class="string">'x-test2'</span> are sent</span>
s.get(<span class="string">'http://httpbin.org/headers'</span>, headers={<span class="string">'x-test2'</span>: <span class="string">'true'</span>})
</code></pre><p>任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。</p>
<blockquote>
<p><strong>从字典参数中移除一个值</strong><br>有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 None ，那个键就会被自动省略掉。<br>包含在一个会话中的所有数据你都可以直接使用。学习更多细节请阅读 会话API文档 。</p>
</blockquote>
<h1 id="请求与响应对象">请求与响应对象</h1><p>任何时候调用requests.*()你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从 服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。如下是一个简单的请求，从Wikipedia的服务器得到 一些非常重要的信息:</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://en.wikipedia.org/wiki/Monty_Python'</span>)</span></span>
</code></pre><p>如果想访问服务器返回给我们的响应头部信息，可以这样做:</p>
<pre><code>&gt;&gt;&gt; r.headers
{<span class="symbol">'content</span>-length': <span class="symbol">'5617</span>0', <span class="symbol">'x</span>-content-<span class="class"><span class="keyword">type</span><span class="title">-options</span>':</span> <span class="symbol">'nosnif</span>f', <span class="symbol">'x</span>-cache':
<span class="symbol">'HIT</span> from cp1006.eqiad.wmnet, <span class="type">MISS</span> from cp1010.eqiad.wmnet', <span class="symbol">'content</span>-encoding':
<span class="symbol">'gzi</span>p', <span class="symbol">'ag</span>e': <span class="symbol">'308</span>0', <span class="symbol">'content</span>-language': <span class="symbol">'e</span>n', <span class="symbol">'var</span>y': <span class="symbol">'Accept</span>-<span class="type">Encoding</span>,<span class="type">Cookie</span>',
<span class="symbol">'serve</span>r': <span class="symbol">'Apach</span>e', <span class="symbol">'last</span>-modified': <span class="symbol">'Wed</span>, <span class="number">13</span> <span class="type">Jun</span> <span class="number">2012</span> <span class="number">01</span>:<span class="number">33</span>:<span class="number">50</span> <span class="type">GMT</span>',
<span class="symbol">'connectio</span>n': <span class="symbol">'clos</span>e', <span class="symbol">'cache</span>-control': <span class="symbol">'private</span>, s-maxage=<span class="number">0</span>, max-age=<span class="number">0</span>,
must-revalidate', <span class="symbol">'dat</span>e': <span class="symbol">'Thu</span>, <span class="number">14</span> <span class="type">Jun</span> <span class="number">2012</span> <span class="number">12</span>:<span class="number">59</span>:<span class="number">39</span> <span class="type">GMT</span>', <span class="symbol">'content</span>-<span class="class"><span class="keyword">type</span>':</span>
<span class="symbol">'text</span>/html; charset=<span class="type">UTF</span>-<span class="number">8</span>', <span class="symbol">'x</span>-cache-lookup': <span class="symbol">'HIT</span> from cp1006.eqiad.wmnet:<span class="number">3128</span>,
<span class="type">MISS</span> from cp1010.eqiad.wmnet:<span class="number">80</span>'}
</code></pre><p>然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; r.request.headers
{<span class="string">'Accept-Encoding'</span><span class="symbol">:</span> <span class="string">'identity, deflate, compress, gzip'</span>,
<span class="string">'Accept'</span><span class="symbol">:</span> <span class="string">'*/*'</span>, <span class="string">'User-Agent'</span><span class="symbol">:</span> <span class="string">'python-requests/0.13.1'</span>}
</code></pre><h1 id="Prepared_Requests">Prepared Requests</h1><p>Whenever you receive a Response object from an API call or a Session call, the request attribute is actually the PreparedRequest that was used. In some cases you may wish to do some extra work to the body or headers (or anything else really) before sending a request. The simple recipe for this is the following:</p>
<pre><code>from requests import Request, Session

s = Session()
req = Request('GET', url,
    data=data,
    headers=header
)
prepped = req.prepare()

# <span class="operator"><span class="keyword">do</span> something <span class="keyword">with</span> prepped.<span class="keyword">body</span>
# <span class="keyword">do</span> something <span class="keyword">with</span> prepped.headers

resp = s.send(prepped,
    stream=stream,
    <span class="keyword">verify</span>=<span class="keyword">verify</span>,
    proxies=proxies,
    cert=cert,
    <span class="keyword">timeout</span>=<span class="keyword">timeout</span>
)

print(resp.status_code)</span>
</code></pre><p>Since you are not doing anything special with the Request object, you prepare it immediately and modify the PreparedRequest object. You then send that with the other parameters you would have sent to requests.<em> or Session.</em>.</p>
<p>However, the above code will lose some of the advantages of having a Requests Session object. In particular, Session-level state such as cookies will not get applied to your request. To get a PreparedRequest with that state applied, replace the call to Request.prepare() with a call to Session.prepare_request(), like this:</p>
<pre><code>from requests import Request, Session

s = Session()
req = Request('GET',  url,
    data=data
    headers=headers
)

prepped = s.prepare_request(req)

# <span class="operator"><span class="keyword">do</span> something <span class="keyword">with</span> prepped.<span class="keyword">body</span>
# <span class="keyword">do</span> something <span class="keyword">with</span> prepped.headers

resp = s.send(prepped,
    stream=stream,
    <span class="keyword">verify</span>=<span class="keyword">verify</span>,
    proxies=proxies,
    cert=cert,
    <span class="keyword">timeout</span>=<span class="keyword">timeout</span>
)

print(resp.status_code)</span>
</code></pre><h1 id="SSL证书验证">SSL证书验证</h1><p>Requests可以为HTTPS请求验证SSL证书，就像web浏览器一样。要想检查某个主机的SSL证书，你可以使用 verify 参数:</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://kennethreitz.com'</span>, verify=True)</span></span>
requests<span class="class">.exceptions</span><span class="class">.SSLError</span>: hostname <span class="string">'kennethreitz.com'</span> doesn<span class="string">'t match either of '</span>*<span class="class">.herokuapp</span><span class="class">.com</span><span class="string">', '</span>herokuapp.com<span class="string">'</span>
</code></pre><p>在该域名上我没有设置SSL，所以失败了。但Github设置了SSL:</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://github.com'</span>, verify=True)</span></span>
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><p>对于私有证书，你也可以传递一个CA_BUNDLE文件的路径给 verify 。你也可以设置 REQUEST_CA_BUNDLE 环境变量。</p>
<p>如果你将 verify 设置为False，Requests也能忽略对SSL证书的验证。</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://kennethreitz.com'</span>, verify=False)</span></span>
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><p>默认情况下， verify 是设置为True的。选项 verify 仅应用于主机证书。</p>
<p>你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组:</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://kennethreitz.com'</span>, cert=(<span class="string">'/path/server.crt'</span>, <span class="string">'/path/key'</span>)</span></span>)
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><p>如果你指定了一个错误路径或一个无效的证书:</p>
<pre><code>&gt;&gt;&gt; requests.get(<span class="string">'https://kennethreitz.com'</span>, cert=<span class="string">'/wrong_path/server.pem'</span>)
<span class="constant">SSLError</span><span class="symbol">:</span> [<span class="constant">Errno</span> <span class="number">336265225</span>] _ssl.<span class="symbol">c:</span><span class="number">347</span><span class="symbol">:</span> <span class="symbol">error:</span><span class="number">140</span><span class="constant">B0009:</span><span class="constant">SSL</span> <span class="symbol">routines:</span><span class="constant">SSL_CTX_use_PrivateKey_file</span><span class="symbol">:PEM</span> <span class="class"><span class="keyword">lib</span></span>
</code></pre><h1 id="响应体内容工作流">响应体内容工作流</h1><p>默认情况下，当你进行网络请求后，响应体会立即被下载。你可以通过 stream 参数覆盖这个行为，推迟下载响应体直到访问 Response.content 属性:</p>
<pre><code><span class="setting">tarball_url = <span class="value"><span class="string">'https://github.com/kennethreitz/requests/tarball/master'</span></span></span>
<span class="setting">r = <span class="value">requests.get(tarball_url, stream=<span class="keyword">True</span>)</span></span>
</code></pre><p>此时仅有响应头被下载下来了，连接保持打开状态，因此允许我们根据条件获取内容:</p>
<pre><code><span class="keyword">if</span> <span class="function"><span class="title">int</span><span class="params">(r.headers[<span class="string">'content-length'</span>])</span></span> &lt; TOO_LONG:
  <span class="attribute">content</span> = r<span class="class">.content</span>
  ...
</code></pre><p>你可以进一步使用 Response.iter_content 和 Response.iter_lines 方法来控制工作流，或者以 Response.raw 从底层urllib3的 urllib3.HTTPResponse &lt;urllib3.response.HTTPResponse 读取。</p>
<p>If you set stream to True when making a request, Requests cannot release the connection back to the pool unless you consume all the data or call Response.close. This can lead to inefficiency with connections. If you find yourself partially reading request bodies (or not reading them at all) while using stream=True, you should consider using contextlib.closing (documented here), like this:</p>
<pre><code><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing

<span class="keyword">with</span> closing(requests.get(<span class="string">'http://httpbin.org/get'</span>, stream=<span class="keyword">True</span>)) <span class="keyword">as</span> r:
    <span class="comment"># Do things with the response here.</span>
</code></pre><h1 id="保持活动状态（持久连接）">保持活动状态（持久连接）</h1><p>好消息 - 归功于urllib3，同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！</p>
<p>注意：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 stream 设置为 False 或读取 Response 对象的 content 属性。</p>
<h1 id="流式上传">流式上传</h1><p>Requests支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可:</p>
<pre><code>with <span class="function"><span class="title">open</span><span class="params">(<span class="string">'massive-body'</span>)</span></span> as f:
    requests.<span class="function"><span class="title">post</span><span class="params">(<span class="string">'http://some.url/streamed'</span>, data=f)</span></span>
</code></pre><h1 id="块编码请求">块编码请求</h1><p>对于出去和进来的请求，Requests也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度(without a length)的迭代器）:</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>
    <span class="keyword">yield</span> <span class="string">'hi'</span>
    <span class="keyword">yield</span> <span class="string">'there'</span>

requests.post(<span class="string">'http://some.url/chunked'</span>, data=gen())
</code></pre><h1 id="POST_Multiple_Multipart-Encoded_Files">POST Multiple Multipart-Encoded Files</h1><p>You can send multiple files in one request. For example, suppose you want to upload image files to an HTML form with a multiple file field ‘images’:</p>
<pre><code><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">”file”</span> <span class="attribute">name</span>=<span class="value">”images”</span> <span class="attribute">multiple</span>=<span class="value">”true”</span> <span class="attribute">required</span>=<span class="value">”true”</span>/&gt;</span>
</code></pre><p>To do that, just set files to a list of tuples of (form_field_name, file_info):</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'http://httpbin.org/post'</span>
<span class="prompt">&gt;&gt;</span>&gt; multiple_files = [(<span class="string">'images'</span>, (<span class="string">'foo.png'</span>, open(<span class="string">'foo.png'</span>, <span class="string">'rb'</span>), <span class="string">'image/png'</span>)),
                      (<span class="string">'images'</span>, (<span class="string">'bar.png'</span>, open(<span class="string">'bar.png'</span>, <span class="string">'rb'</span>), <span class="string">'image/png'</span>))]
<span class="prompt">&gt;&gt;</span>&gt; r = requests.post(url, files=multiple_files)
<span class="prompt">&gt;&gt;</span>&gt; r.text
{
  ...
  <span class="string">'files'</span><span class="symbol">:</span> {<span class="string">'images'</span><span class="symbol">:</span> <span class="string">'data:image/png;base64,iVBORw ....'</span>}
  <span class="string">'Content-Type'</span><span class="symbol">:</span> <span class="string">'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a'</span>,
  ...
}
</code></pre><h1 id="事件挂钩">事件挂钩</h1><p>Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。</p>
<p>可用的钩子:</p>
<p>response:</p>
<p>从一个请求产生的响应<br>你可以通过传递一个 {hook_name: callback_function} 字典给 hooks 请求参数 为每个请求分配一个钩子函数:</p>
<pre><code>hooks=<span class="function"><span class="title">dict</span><span class="params">(response=print_url)</span></span>
</code></pre><p>callback_function 会接受一个数据块作为它的第一个参数。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">print_url</span><span class="params">(r)</span>:</span>
    print(r.url)
</code></pre><p>若执行你的回调函数期间发生错误，系统会给出一个警告。</p>
<p>若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西， 也没有什么其他的影响。</p>
<p>我们来在运行期间打印一些请求方法的参数:</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://httpbin.org'</span>, hooks=dict(response=print_url)</span></span>)
http:<span class="comment">//httpbin.org</span>
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><h1 id="自定义身份验证">自定义身份验证</h1><p>Requests允许你使用自己指定的身份验证机制。</p>
<p>任何传递给请求方法的 auth 参数的可调用对象，在请求发出之前都有机会修改请求。</p>
<p>自定义的身份验证机制是作为 requests.auth.AuthBase 的子类来实现的，也非常容易定义。</p>
<p>Requests在 requests.auth 中提供了两种常见的的身份验证方案： HTTPBasicAuth 和 HTTPDigestAuth 。</p>
<p>假设我们有一个web服务，仅在 X-Pizza 头被设置为一个密码值的情况下才会有响应。虽然这不太可能， 但就以它为例好了</p>
<pre><code><span class="keyword">from</span> requests.auth <span class="keyword">import</span> AuthBase

<span class="class"><span class="keyword">class</span> <span class="title">PizzaAuth</span><span class="params">(AuthBase)</span>:</span>
    <span class="string">"""Attaches HTTP Pizza Authentication to the given Request object."""</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username)</span>:</span>
        <span class="comment"># setup any auth-related data here</span>
        self.username = username

    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, r)</span>:</span>
        <span class="comment"># modify and return the request</span>
        r.headers[<span class="string">'X-Pizza'</span>] = self.username
        <span class="keyword">return</span> r
</code></pre><p>然后就可以使用我们的PizzaAuth来进行网络请求:</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://pizzabin.org/admin'</span>, auth=PizzaAuth(<span class="string">'kenneth'</span>)</span></span>)
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><h1 id="流式请求">流式请求</h1><p>使用 requests.Response.iter_lines() 你可以很方便地对流式API（例如 Twitter的流式API ）进行迭代。简单地设置 stream 为 True 便可以使用 iter_lines() 对相应进行迭代:</p>
<pre><code><span class="keyword">import</span> json
<span class="keyword">import</span> requests

r = requests.<span class="built_in">get</span>(<span class="string">'http://httpbin.org/stream/20'</span>, stream=True)

<span class="keyword">for</span> <span class="built_in">line</span> in r.iter_lines():

    # <span class="built_in">filter</span> out keep-alive <span class="keyword">new</span> lines
    <span class="keyword">if</span> <span class="built_in">line</span>:
        <span class="built_in">print</span>(json.loads(<span class="built_in">line</span>))
</code></pre><h1 id="代理">代理</h1><p>如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求:</p>
<pre><code><span class="keyword">import</span> requests

proxies = {
  <span class="string">"http"</span>: <span class="string">"http://10.10.1.10:3128"</span>,
  <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,
}

requests.<span class="keyword">get</span>(<span class="string">"http://example.org"</span>, proxies=proxies)
</code></pre><p>你也可以通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理。</p>
<pre><code><span class="variable">$ </span>export <span class="constant">HTTP_PROXY</span>=<span class="string">"http://10.10.1.10:3128"</span>
<span class="variable">$ </span>export <span class="constant">HTTPS_PROXY</span>=<span class="string">"http://10.10.1.10:1080"</span>
<span class="variable">$ </span>python
<span class="prompt">&gt;&gt;</span>&gt; import requests
<span class="prompt">&gt;&gt;</span>&gt; requests.get(<span class="string">"http://example.org"</span>)
</code></pre><p>若你的代理需要使用HTTP Basic Auth，可以使用 <a href="http://user:password@host/" target="_blank" rel="external">http://user:password@host/</a> 语法:</p>
<pre><code>proxies = {
    <span class="string">"http"</span>: <span class="string">"http://user:pass<span class="variable">@10</span>.10.1.10:3128/"</span>,
}
</code></pre><h1 id="合规性">合规性</h1><p>Requests符合所有相关的规范和RFC，这样不会为用户造成不必要的困难。但这种对规范的考虑 导致一些行为对于不熟悉相关规范的人来说看似有点奇怪。</p>
<h1 id="编码方式">编码方式</h1><p>当你收到一个响应时，Requests会猜测响应的编码方式，用于在你调用 Response.text 方法时 对响应进行解码。Requests首先在HTTP头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。</p>
<p>只有当HTTP头部不存在明确指定的字符集，并且 Content-Type 头部字段包含 text 值之时， Requests才不去猜测编码方式。</p>
<p>在这种情况下， RFC 2616 指定默认字符集 必须是 ISO-8859-1 。Requests遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置 Response.encoding 属性，或使用原始的 Response.content 。</p>
<h1 id="HTTP动词">HTTP动词</h1><p>Requests提供了几乎所有HTTP动词的功能：GET，OPTIONS， HEAD，POST，PUT，PATCH和DELETE。 以下内容为使用Requests中的这些动词以及Github API提供了详细示例。</p>
<p>我将从最常使用的动词GET开始。HTTP GET是一个幂等的方法，从给定的URL返回一个资源。因而， 当你试图从一个web位置获取数据之时，你应该使用这个动词。一个使用示例是尝试从Github上获取 关于一个特定commit的信息。假设我们想获取Requests的commit a050faf 的信息。我们可以 这样去做:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import requests
<span class="prompt">&gt;&gt;</span>&gt; r = requests.get(<span class="string">'https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad'</span>)
</code></pre><p>我们应该确认Github是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做:</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">if</span> (r.status_code == requests.codes.ok):
<span class="prompt">... </span>    <span class="keyword">print</span> r.headers[<span class="string">'content-type'</span>]
...
application/json; charset=utf-<span class="number">8</span>
</code></pre><p>可见，GitHub返回了JSON数据，非常好，这样就可以使用 r.json 方法把这个返回的数据解析成Python对象。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span>commit_data = r.json()
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> commit_data.keys()
[<span class="string">u'committer'</span>, <span class="string">u'author'</span>, <span class="string">u'url'</span>, <span class="string">u'tree'</span>, <span class="string">u'sha'</span>, <span class="string">u'parents'</span>, <span class="string">u'message'</span>]
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> commit_data[<span class="string">u'committer'</span>]
{<span class="string">u'date'</span>: <span class="string">u'2012-05-10T11:10:50-07:00'</span>, <span class="string">u'email'</span>: <span class="string">u'me@kennethreitz.com'</span>, <span class="string">u'name'</span>: <span class="string">u'Kenneth Reitz'</span>}
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> commit_data[<span class="string">u'message'</span>]
makin<span class="string">' history</span>
</code></pre><p>到目前为止，一切都非常简单。嗯，我们来研究一下GitHub的API。我们可以去看看文档， 但如果使用Requests来研究也许会更有意思一点。我们可以借助Requests的OPTIONS动词来看看我们刚使用过的url 支持哪些HTTP方法。</p>
<pre><code>&gt;&gt;&gt; verbs = requests.<span class="function"><span class="title">options</span><span class="params">(r.url)</span></span>
&gt;&gt;&gt; verbs<span class="class">.status_code</span>
<span class="number">500</span>
</code></pre><p>额，这是怎么回事？毫无帮助嘛！原来GitHub，与许多API提供方一样，实际上并未实现OPTIONS方法。 这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，如果GitHub正确实现了OPTIONS， 那么服务器应该在响应头中返回允许用户使用的HTTP方法，例如</p>
<pre><code>&gt;&gt;&gt; verbs = requests.<span class="function"><span class="title">options</span><span class="params">(<span class="string">'http://a-good-website.com/api/cats'</span>)</span></span>
&gt;&gt;&gt; print verbs<span class="class">.headers</span>[<span class="string">'allow'</span>]
GET,HEAD,POST,OPTIONS
</code></pre><p>转而去查看文档，我们看到对于提交信息，另一个允许的方法是POST，它会创建一个新的提交。 由于我们正在使用Requests代码库，我们应尽可能避免对它发送笨拙的POST。作为替代，我们来 玩玩GitHub的Issue特性。</p>
<p>本篇文档是回应Issue #482而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://api.github.com/repos/kennethreitz/requests/issues/482'</span>)
<span class="prompt">&gt;&gt;&gt; </span>r.status_code
<span class="number">200</span>
<span class="prompt">&gt;&gt;&gt; </span>issue = json.loads(r.text)
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> issue[<span class="string">u'title'</span>]
Feature any http verb <span class="keyword">in</span> docs
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> issue[<span class="string">u'comments'</span>]
<span class="number">3</span>
</code></pre><p>Cool，有3个评论。我们来看一下最后一个评论。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span>r = requests.get(r.url + <span class="string">u'/comments'</span>)
<span class="prompt">&gt;&gt;&gt; </span>r.status_code
<span class="number">200</span>
<span class="prompt">&gt;&gt;&gt; </span>comments = r.json()
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> comments[<span class="number">0</span>].keys()
[<span class="string">u'body'</span>, <span class="string">u'url'</span>, <span class="string">u'created_at'</span>, <span class="string">u'updated_at'</span>, <span class="string">u'user'</span>, <span class="string">u'id'</span>]
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> comments[<span class="number">2</span>][<span class="string">u'body'</span>]
Probably <span class="keyword">in</span> the <span class="string">"advanced"</span> section
</code></pre><p>嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> comments[<span class="number">2</span>][<span class="string">u'user'</span>][<span class="string">u'login'</span>]
kennethreitz
</code></pre><p>好，我们来告诉这个叫肯尼思的家伙，这个例子应该放在快速上手指南中。根据GitHub API文档， 其方法是POST到该话题。我们来试试看。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span>body = json.dumps({<span class="string">u"body"</span>: <span class="string">u"Sounds great! I'll get right on it!"</span>})
<span class="prompt">&gt;&gt;&gt; </span>url = <span class="string">u"https://api.github.com/repos/kennethreitz/requests/issues/482/comments"</span>
<span class="prompt">&gt;&gt;&gt; </span>r = requests.post(url=url, data=body)
<span class="prompt">&gt;&gt;&gt; </span>r.status_code
<span class="number">404</span>
</code></pre><p>额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests简化了多种身份验证形式的使用， 包括非常常见的Basic Auth。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth
<span class="prompt">&gt;&gt;&gt; </span>auth = HTTPBasicAuth(<span class="string">'fake@example.com'</span>, <span class="string">'not_a_real_password'</span>)
<span class="prompt">&gt;&gt;&gt; </span>r = requests.post(url=url, data=body, auth=auth)
<span class="prompt">&gt;&gt;&gt; </span>r.status_code
<span class="number">201</span>
<span class="prompt">&gt;&gt;&gt; </span>content = r.json()
<span class="prompt">&gt;&gt;&gt; </span>print(content[<span class="string">u'body'</span>])
Sounds great! I<span class="string">'ll get right on it.</span>
</code></pre><p>精彩！噢，不！我原本是想说等我一会，因为我得去喂一下我的猫。如果我能够编辑这条评论那就好了！ 幸运的是，GitHub允许我们使用另一个HTTP动词，PATCH，来编辑评论。我们来试试。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span>print(content[<span class="string">u"id"</span>])
<span class="number">5804413</span>
<span class="prompt">&gt;&gt;&gt; </span>body = json.dumps({<span class="string">u"body"</span>: <span class="string">u"Sounds great! I'll get right on it once I feed my cat."</span>})
<span class="prompt">&gt;&gt;&gt; </span>url = <span class="string">u"https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413"</span>
<span class="prompt">&gt;&gt;&gt; </span>r = requests.patch(url=url, data=body, auth=auth)
<span class="prompt">&gt;&gt;&gt; </span>r.status_code
<span class="number">200</span>
</code></pre><p>非常好。现在，我们来折磨一下这个叫肯尼思的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。 这意味着我想删除这条评论。GitHub允许我们使用完全名副其实的DELETE方法来删除评论。我们来清除该评论。</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">delete</span><span class="params">(url=url, auth=auth)</span></span>
&gt;&gt;&gt; r<span class="class">.status_code</span>
<span class="number">204</span>
&gt;&gt;&gt; r<span class="class">.headers</span>[<span class="string">'status'</span>]
<span class="string">'204 No Content'</span>
</code></pre><p>很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub在响应头部发送这个信息， 因此不必下载整个网页，我将使用一个HEAD请求来获取响应头。</p>
<pre><code>&gt;&gt;&gt; r = requests.<span class="function"><span class="title">head</span><span class="params">(url=url, auth=auth)</span></span>
&gt;&gt;&gt; print r<span class="class">.headers</span>
...
<span class="string">'x-ratelimit-remaining'</span>: <span class="string">'4995'</span>
<span class="string">'x-ratelimit-limit'</span>: <span class="string">'5000'</span>
...
</code></pre><p>很好。是时候写个Python程序以各种刺激的方式滥用GitHub的API，还可以使用4995次呢。</p>
<h1 id="响应头链接字段">响应头链接字段</h1><p>许多HTTP API都有响应头链接字段的特性，它们使得API能够更好地自我描述和自我显露。</p>
<p>GitHub在API中为 分页 使用这些特性，例如:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'https://api.github.com/users/kennethreitz/repos?page=1&amp;per_page=10'</span>
<span class="prompt">&gt;&gt;</span>&gt; r = requests.head(url=url)
<span class="prompt">&gt;&gt;</span>&gt; r.headers[<span class="string">'link'</span>]
<span class="string">'&lt;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&gt;; rel="next", &lt;https://api.github.com/users/kennethreitz/repos?page=6&amp;per_page=10&gt;; rel="last"'</span>
</code></pre><p>Requests会自动解析这些响应头链接字段，并使得它们非常易于使用:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; r.links[<span class="string">"next"</span>]
{<span class="string">'url'</span><span class="symbol">:</span> <span class="string">'https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10'</span>, <span class="string">'rel'</span><span class="symbol">:</span> <span class="string">'next'</span>}

<span class="prompt">&gt;&gt;</span>&gt; r.links[<span class="string">"last"</span>]
{<span class="string">'url'</span><span class="symbol">:</span> <span class="string">'https://api.github.com/users/kennethreitz/repos?page=7&amp;per_page=10'</span>, <span class="string">'rel'</span><span class="symbol">:</span> <span class="string">'last'</span>}
</code></pre><h1 id="基本身份认证">基本身份认证</h1><p>许多要求身份认证的web服务都接受HTTP Basic Auth。这是最简单的一种身份认证，并且Requests 对这种认证方式的支持是直接开箱即可用。</p>
<p>以HTTP Basic Auth发送请求非常简单:</p>
<pre><code>&gt;&gt;&gt; from requests<span class="class">.auth</span> import HTTPBasicAuth
&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://api.github.com/user'</span>, auth=HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span></span>)
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><p>事实上，HTTP Basic Auth如此常见，Requests就提供了一种简写的使用方式:</p>
<pre><code>&gt;&gt;&gt; requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'https://api.github.com/user'</span>, auth=(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span></span>)
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><p>像这样在一个元组中提供认证信息与前一个 HTTPBasicAuth 例子是完全相同的。</p>
<p>netrc Authentication<br>If no authentication method is given with the auth argument, Requests will attempt to get the authentication credentials for the URL’s hostname from the user’s netrc file.</p>
<p>If credentials for the hostname are found, the request is sent with HTTP Basic Auth.</p>
<p>摘要式身份认证<br>另一种非常流行的HTTP身份认证形式是摘要式身份认证，Requests对它的支持也是开箱即可用的:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; from requests.auth import <span class="constant">HTTPDigestAuth</span>
<span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'http://httpbin.org/digest-auth/auth/user/pass'</span>
<span class="prompt">&gt;&gt;</span>&gt; requests.get(url, auth=<span class="constant">HTTPDigestAuth</span>(<span class="string">'user'</span>, <span class="string">'pass'</span>))
&lt;<span class="constant">Response</span> [<span class="number">200</span>]&gt;
</code></pre><h1 id="OAuth_1_Authentication">OAuth 1 Authentication</h1><p>A common form of authentication for several web APIs is OAuth. The requests-oauthlib library allows Requests users to easily make OAuth authenticated requests:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import requests
<span class="prompt">&gt;&gt;</span>&gt; from requests_oauthlib import <span class="constant">OAuth1</span>

<span class="prompt">&gt;&gt;</span>&gt; url = <span class="string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span>
<span class="prompt">&gt;&gt;</span>&gt; auth = <span class="constant">OAuth1</span>(<span class="string">'YOUR_APP_KEY'</span>, <span class="string">'YOUR_APP_SECRET'</span>,
                  <span class="string">'USER_OAUTH_TOKEN'</span>, <span class="string">'USER_OAUTH_TOKEN_SECRET'</span>)

<span class="prompt">&gt;&gt;</span>&gt; requests.get(url, auth=auth)
&lt;<span class="constant">Response</span> [<span class="number">200</span>]&gt;
</code></pre><p>For more information on how to OAuth flow works, please see the official OAuth website. For examples and documentation on requests-oauthlib, please see the requests_oauthlib repository on GitHub</p>
<h1 id="其他身份认证形式">其他身份认证形式</h1><p>Requests被设计成允许其他形式的身份认证非常容易快速地插入其中。开源社区的成员 时常为更复杂或不那么常用的身份认证形式编写认证处理插件。其中一些最优秀的已被 收集在 Requests organization 页面中，包括:</p>
<p>Kerberos<br>NTLM<br>如果你想使用其中任何一种身份认证形式，直接去它们的GitHub页面，依照说明进行。</p>
<h1 id="新的身份认证形式">新的身份认证形式</h1><p>如果你找不到所需要的身份认证形式的一个良好实现，你也可以自己实现它。Requests非常易于添加你自己的身份认证形式。</p>
<p>要想自己实现，就从 requests.auth.AuthBase 继承一个子类，并实现 <strong>call</strong>() 方法:</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> requests
<span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyAuth</span><span class="params">(requests.auth.AuthBase)</span>:</span>
<span class="prompt">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, r)</span>:</span>
<span class="prompt">... </span>        <span class="comment"># Implement my authentication</span>
<span class="prompt">... </span>        <span class="keyword">return</span> r
...
<span class="prompt">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/get'</span>
<span class="prompt">&gt;&gt;&gt; </span>requests.get(url, auth=MyAuth())
&lt;Response [<span class="number">200</span>]&gt;
</code></pre><p>当一个身份认证模块被附加到一个请求上，在设置request期间就会调用该模块。因此 <strong>call</strong> 方法必须完成使得身份认证生效的所有事情。一些身份认证形式会额外地添加钩子来提供进一步的功能。</p>
<h1 id="参考">参考</h1><p><a href="http://cn.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="external">Requests 快速上手</a><br><a href="http://cn.python-requests.org/zh_CN/latest/user/advanced.html#advanced" target="_blank" rel="external">Requests 高级用法</a><br><a href="http://cn.python-requests.org/zh_CN/latest/user/authentication.html" target="_blank" rel="external">Requests 身份认证</a>  </p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag">#python</a>
          
            <a href="/tags/python库/" rel="tag">#python库</a>
          
            <a href="/tags/入门教程/" rel="tag">#入门教程</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/09/13/python乱码/" rel="prev">python乱码</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/09/10/三国进度条/" rel="next">三国进度条</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div class="ds-thread" data-thread-key="2015/09/13/python的requests库/"
                   data-title="python的requests库" data-url="http://kuku940.github.io/2015/09/13/python的requests库/">
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点简介
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xljab.com1.z0.glb.clouddn.com/博客|个人博客|不卜个人博客|不卜" alt="不卜" itemprop="image"/>
          <p class="site-author-name" itemprop="name">不卜</p>
        </div>
        <p class="site-description motion-element" itemprop="description">善易者不卜</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kuku940" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/roingeek" target="_blank">ZhiHu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">友情链接</p>
            
              <span class="links-of-author-item">
              <a href="http://zhumang.top/" target="_blank">竹芒</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python命令行简单示例"><span class="nav-number">1.</span> <span class="nav-text">Python命令行简单示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#发送请求"><span class="nav-number">3.</span> <span class="nav-text">发送请求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为URL传递参数"><span class="nav-number">4.</span> <span class="nav-text">为URL传递参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#响应内容"><span class="nav-number">5.</span> <span class="nav-text">响应内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二进制响应内容"><span class="nav-number">6.</span> <span class="nav-text">二进制响应内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSON响应内容"><span class="nav-number">7.</span> <span class="nav-text">JSON响应内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原始响应内容"><span class="nav-number">8.</span> <span class="nav-text">原始响应内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定制请求头"><span class="nav-number">9.</span> <span class="nav-text">定制请求头</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更加复杂的POST请求"><span class="nav-number">10.</span> <span class="nav-text">更加复杂的POST请求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#POST一个多部分编码(Multipart-Encoded)的文件"><span class="nav-number">11.</span> <span class="nav-text">POST一个多部分编码(Multipart-Encoded)的文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#响应状态码"><span class="nav-number">12.</span> <span class="nav-text">响应状态码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#响应头"><span class="nav-number">13.</span> <span class="nav-text">响应头</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重定向与请求历史"><span class="nav-number">14.</span> <span class="nav-text">重定向与请求历史</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#超时"><span class="nav-number">15.</span> <span class="nav-text">超时</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误与异常"><span class="nav-number">16.</span> <span class="nav-text">错误与异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请求与响应对象"><span class="nav-number">17.</span> <span class="nav-text">请求与响应对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Prepared_Requests"><span class="nav-number">18.</span> <span class="nav-text">Prepared Requests</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SSL证书验证"><span class="nav-number">19.</span> <span class="nav-text">SSL证书验证</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#响应体内容工作流"><span class="nav-number">20.</span> <span class="nav-text">响应体内容工作流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保持活动状态（持久连接）"><span class="nav-number">21.</span> <span class="nav-text">保持活动状态（持久连接）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流式上传"><span class="nav-number">22.</span> <span class="nav-text">流式上传</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#块编码请求"><span class="nav-number">23.</span> <span class="nav-text">块编码请求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#POST_Multiple_Multipart-Encoded_Files"><span class="nav-number">24.</span> <span class="nav-text">POST Multiple Multipart-Encoded Files</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件挂钩"><span class="nav-number">25.</span> <span class="nav-text">事件挂钩</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义身份验证"><span class="nav-number">26.</span> <span class="nav-text">自定义身份验证</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流式请求"><span class="nav-number">27.</span> <span class="nav-text">流式请求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代理"><span class="nav-number">28.</span> <span class="nav-text">代理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#合规性"><span class="nav-number">29.</span> <span class="nav-text">合规性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编码方式"><span class="nav-number">30.</span> <span class="nav-text">编码方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP动词"><span class="nav-number">31.</span> <span class="nav-text">HTTP动词</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#响应头链接字段"><span class="nav-number">32.</span> <span class="nav-text">响应头链接字段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本身份认证"><span class="nav-number">33.</span> <span class="nav-text">基本身份认证</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OAuth_1_Authentication"><span class="nav-number">34.</span> <span class="nav-text">OAuth 1 Authentication</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他身份认证形式"><span class="nav-number">35.</span> <span class="nav-text">其他身份认证形式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#新的身份认证形式"><span class="nav-number">36.</span> <span class="nav-text">新的身份认证形式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">37.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不卜</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 搭建
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"roingeek"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"3","bdPos":"left","bdTop":"250"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>



  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
